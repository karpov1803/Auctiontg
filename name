# bot.py
import asyncio, aiohttp, re, logging
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import FSInputFile

# === –í–°–¢–ê–í–¨ –°–í–û–ò –î–ê–ù–ù–´–ï ===
TOKEN = "777777777:AAE..."          # ‚Üê —Ç–≤–æ–π —Ç–æ–∫–µ–Ω –æ—Ç @BotFather
ALLOWED_ID = 123456789               # ‚Üê —Ç–≤–æ–π Telegram ID (—É–∑–Ω–∞–π —É @userinfobot)

BASE_URL = "https://raw.githubusercontent.com/karpov1803/name/main/"

bot = Bot(token=TOKEN)
dp = Dispatcher()

task = None
stop_event = None
current_file = None

# === –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö .txt —Ñ–∞–π–ª–æ–≤ –∏–∑ –ø–∞–ø–∫–∏ ===
async def get_file_list():
    url = "https://github.com/karpov1803/name"
    async with aiohttp.ClientSession() as s:
        async with s.get(url) as r:
            html = await r.text()
    files = re.findall(r'href="[^"]+/blob/main/([^"]+\.txt)"', html)
    return [f for f in files if f.endswith('.txt')]

# === –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å —Ñ–∞–π–ª–∞–º–∏ ===
async def files_keyboard():
    files = await get_file_list()
    buttons = [[types.KeyboardButton(text=f"üìÑ {f}")] for f in files]
    buttons += [
        [types.KeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫")],
        [types.KeyboardButton(text="üöÄ –°–¢–ê–†–¢"), types.KeyboardButton(text="üõë –°–¢–û–ü")],
        [types.KeyboardButton(text="üìä –°—Ç–∞—Ç—É—Å")]
    ]
    return types.ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)

# === –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ ===
async def load_usernames(file_name):
    url = BASE_URL + file_name
    async with aiohttp.ClientSession() as s:
        async with s.get(url) as r:
            if r.status != 200: return []
            text = await r.text()
    return [line.strip() for line in text.splitlines() if line.strip() and len(line.strip()) >= 5]

# === –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–¥–Ω–æ–≥–æ –∏–º–µ–Ω–∏ ===
async def check(name, session):
    if stop_event.is_set(): return None
    try:
        async with session.get(f"https://fragment.com/username/{name.lower()}", timeout=8) as r:
            if "available" not in await r.text(): return None
        async with session.get(f"https://t.me/{name}", timeout=8) as r:
            if "empty" not in await r.text(): return None
        return name
    except:
        return None

# === –û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ ===
async def start_checking(message: types.Message, file_name):
    global task, stop_event, current_file
    if task and not task.done():
        return await message.answer("‚è≥ –£–∂–µ –∏–¥—ë—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞!")
    
    current_file = file_name
    stop_event = asyncio.Event()
    usernames = await load_usernames(file_name)
    if not usernames:
        return await message.answer("–§–∞–π–ª –ø—É—Å—Ç–æ–π –∏–ª–∏ –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏")

    await message.answer(f"–ó–∞–ø—É—Å–∫–∞—é –ø—Ä–æ–≤–µ—Ä–∫—É\nüìÑ {file_name}\n–í—Å–µ–≥–æ: {len(usernames)}", 
                        reply_markup=types.ReplyKeyboardRemove())
    
    free = []
    async with aiohttp.ClientSession() as session:
        for i, name in enumerate(usernames, 1):
            if stop_event.is_set(): 
                await message.answer("–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!")
                break
            result = await check(name, session)
            if result:
                free.append(result)
                await message.answer(f"@{result}")
            if i % 10 == 0:
                await message.answer(f"–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {i}/{len(usernames)}")
            await asyncio.sleep(1.1)  # –∞–Ω—Ç–∏–±–∞–Ω

    if free:
        path = "free.txt"
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(f"@{x}" for x in free))
        await message.answer(f"–ì–û–¢–û–í–û! –ù–∞–π–¥–µ–Ω–æ: {len(free)}")
        await bot.send_document(message.chat.id, FSInputFile(path), caption=file_name)
    else:
        await message.answer("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

    task = None
    await message.answer("–ì–æ—Ç–æ–≤ –∫ –Ω–æ–≤–æ–π –ø—Ä–æ–≤–µ—Ä–∫–µ!", reply_markup=await files_keyboard())

# === –ö–æ–º–∞–Ω–¥—ã ===
@dp.message(Command("start"))
async def start(m: types.Message):
    if m.from_user.id != ALLOWED_ID:
        return await m.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω")
    await m.answer(
        "–ü—Ä–∏–≤–µ—Ç, –±–æ—Å—Å!\n"
        "–Ø –≤–∏–∂—É –≤—Å–µ .txt —Ñ–∞–π–ª—ã –≤ —Ç–≤–æ–µ–π –ø–∞–ø–∫–µ.\n"
        "–í—ã–±–µ—Ä–∏ —Ñ–∞–π–ª ‚Üí –∂–º–∏ –°–¢–ê–†–¢",
        reply_markup=await files_keyboard()
    )

@dp.message(lambda m: m.text and m.text.startswith("üìÑ "))
async def select_file(m: types.Message):
    global current_file
    file_name = m.text[2:].strip()
    current_file = file_name
    await m.answer(f"–í—ã–±—Ä–∞–Ω: {file_name}\n–ñ–º–∏ üöÄ –°–¢–ê–†–¢", 
                   reply_markup=types.ReplyKeyboardMarkup(keyboard=[
                       [[types.KeyboardButton("üöÄ –°–¢–ê–†–¢"), types.KeyboardButton("üõë –°–¢–û–ü")]]
                   ], resize_keyboard=True))

@dp.message(lambda m: m.text == "üöÄ –°–¢–ê–†–¢")
async def btn_start(m: types.Message):
    if not current_file:
        return await m.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —Ñ–∞–π–ª!")
    await m.answer("–ó–∞–ø—É—Å–∫–∞—é...")
    global task
    task = asyncio.create_task(start_checking(m, current_file))

@dp.message(lambda m: m.text == "üõë –°–¢–û–ü")
async def btn_stop(m: types.Message):
    global task, stop_event
    if stop_event: stop_event.set()
    if task: task.cancel()
    await m.answer("–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!")

@dp.message(lambda m: m.text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫")
async def refresh(m: types.Message):
    await m.answer("–û–±–Ω–æ–≤–ª—è—é...", reply_markup=await files_keyboard())

@dp.message(lambda m: m.text == "üìä –°—Ç–∞—Ç—É—Å")
async def status(m: types.Message):
    if task and not task.done():
        await m.answer("–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ...")
    else:
        await m.answer(f"–ì–æ—Ç–æ–≤. –§–∞–π–ª: {current_file or '–Ω–µ –≤—ã–±—Ä–∞–Ω'}")

# === –ó–∞–ø—É—Å–∫ ===
async def main():
    logging.basicConfig(level=logging.INFO)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())